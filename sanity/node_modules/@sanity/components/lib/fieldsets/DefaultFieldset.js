"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defaultStyle = _interopRequireDefault(require("part:@sanity/components/fieldsets/default-style"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _arrowDropDown = _interopRequireDefault(require("part:@sanity/base/arrow-drop-down"));

var _status = _interopRequireDefault(require("part:@sanity/components/validation/status"));

var _FieldStatus = _interopRequireDefault(require("./FieldStatus"));

var _paths = require("@sanity/util/paths");

var _presence = require("../presence");

var _default = _interopRequireDefault(require("part:@sanity/components/labels/default"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Fieldset extends _react.default.PureComponent {
  constructor(props) {
    super();

    _defineProperty(this, "handleToggle", () => {
      this.setState(prevState => ({
        isCollapsed: !prevState.isCollapsed,
        hasBeenToggled: true
      })); // Let parent know field has been toggled

      var onFocus = this.props.onFocus;

      if (onFocus) {
        onFocus([_paths.FOCUS_TERMINATOR]);
      }
    });

    _defineProperty(this, "handleFocus", event => {
      if (event.target === this._focusElement) {
        // Make sure we don't trigger onFocus for child elements
        this.props.onFocus(event);
      }
    });

    _defineProperty(this, "setFocusElement", el => {
      this._focusElement = el;
    });

    this.state = {
      isCollapsed: props.isCollapsed,
      hasBeenToggled: false
    };
  }

  focus() {
    this._focusElement.focus();
  }

  render() {
    var _this$props = this.props,
        fieldset = _this$props.fieldset,
        legend = _this$props.legend,
        description = _this$props.description,
        columns = _this$props.columns,
        level = _this$props.level,
        className = _this$props.className,
        isCollapsible = _this$props.isCollapsible,
        _ignore = _this$props.isCollapsed,
        children = _this$props.children,
        tabIndex = _this$props.tabIndex,
        transparent = _this$props.transparent,
        markers = _this$props.markers,
        presence = _this$props.presence,
        rest = _objectWithoutProperties(_this$props, ["fieldset", "legend", "description", "columns", "level", "className", "isCollapsible", "isCollapsed", "children", "tabIndex", "transparent", "markers", "presence"]);

    var _this$state = this.state,
        isCollapsed = _this$state.isCollapsed,
        hasBeenToggled = _this$state.hasBeenToggled;

    var styles = _objectSpread(_objectSpread({}, _defaultStyle.default), this.props.styles);

    var validation = markers.filter(marker => marker.type === 'validation'); // const errors = validation.filter(marker => marker.level === 'error')

    var rootClassName = [styles.root, styles["columns".concat(columns)], styles["level".concat(level)], transparent && styles.transparent, this.props.onFocus && styles.canFocus, className].filter(Boolean).join(' '); // Only show a summary of validation issues if field is collapsible and has been collapsed

    var showSummary = isCollapsible && isCollapsed; // Hide the tooltip if field is collapsible, but field is not collapsed

    var hideTooltip = isCollapsible && !isCollapsed;
    return /*#__PURE__*/_react.default.createElement("div", _extends({}, rest, {
      onFocus: this.handleFocus,
      tabIndex: tabIndex,
      ref: this.setFocusElement,
      className: rootClassName
    }), /*#__PURE__*/_react.default.createElement("fieldset", {
      className: styles.fieldset
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: styles.inner
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: styles.header
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: styles.headerMain
    }, /*#__PURE__*/_react.default.createElement("legend", {
      className: "".concat(styles.legend, " ").concat(isCollapsed ? '' : styles.isOpen) // Uses the tabIndex 0 and -1 here to avoid focus state on click
      ,
      tabIndex: isCollapsible ? 0 : undefined // eslint-disable-next-line react/jsx-no-bind
      ,
      onKeyDown: event => event.key === 'Enter' ? this.handleToggle() : false
    }, /*#__PURE__*/_react.default.createElement("div", {
      tabIndex: -1,
      onClick: isCollapsible ? this.handleToggle : undefined,
      style: {
        outline: 'none',
        display: 'flex',
        alignItems: 'center'
      }
    }, isCollapsible && /*#__PURE__*/_react.default.createElement("div", {
      className: "".concat(styles.arrow, " ").concat(isCollapsed ? '' : styles.isOpen)
    }, /*#__PURE__*/_react.default.createElement(_arrowDropDown.default, null)), /*#__PURE__*/_react.default.createElement(_default.default, {
      className: styles.label
    }, legend || fieldset.legend)), /*#__PURE__*/_react.default.createElement(_status.default, {
      markers: showSummary ? validation.filter(marker => marker.path.length <= level) : validation.filter(marker => marker.path.length < 1),
      showSummary: showSummary,
      hideTooltip: hideTooltip
    })), (description || fieldset.description) && /*#__PURE__*/_react.default.createElement("p", {
      className: "".concat(styles.description, " ").concat(isCollapsed ? '' : styles.isOpen)
    }, description || fieldset.description)), /*#__PURE__*/_react.default.createElement(_FieldStatus.default, null, /*#__PURE__*/_react.default.createElement(_presence.FieldPresence, {
      presence: presence
    }))), isCollapsible && !isCollapsed && /*#__PURE__*/_react.default.createElement("div", {
      duration: 250,
      height: isCollapsed && children ? 0 : 'auto',
      className: styles.content
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: styles.fieldWrapper
    }, (hasBeenToggled || !isCollapsed) && children)), !isCollapsible && /*#__PURE__*/_react.default.createElement("div", {
      className: styles.content
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: styles.fieldWrapper
    }, children)))));
  }

}

exports.default = Fieldset;

_defineProperty(Fieldset, "propTypes", {
  description: _propTypes.default.string,
  legend: _propTypes.default.string.isRequired,
  columns: _propTypes.default.number,
  isCollapsible: _propTypes.default.bool,
  onFocus: _propTypes.default.func,
  isCollapsed: _propTypes.default.bool,
  fieldset: _propTypes.default.shape({
    description: _propTypes.default.string,
    legend: _propTypes.default.string
  }),
  children: _propTypes.default.node,
  level: _propTypes.default.number,
  className: _propTypes.default.string,
  tabIndex: _propTypes.default.number,
  transparent: _propTypes.default.bool,
  styles: _propTypes.default.object,
  markers: _propTypes.default.array,
  presence: _propTypes.default.array
});

_defineProperty(Fieldset, "defaultProps", {
  children: undefined,
  className: '',
  columns: undefined,
  description: undefined,
  level: 1,
  fieldset: {},
  isCollapsed: false,
  isCollapsible: false,
  // can collapsing be toggled by user?
  markers: [],
  onFocus: undefined,
  styles: undefined,
  tabIndex: undefined,
  transparent: undefined,
  presence: []
});